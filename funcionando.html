<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Cut Web (ffmpeg.wasm)</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg/dist/ffmpeg.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f4f4f4; }
        .container { max-width: 800px; margin: 0 auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        input[type="file"], button { padding: 10px; margin-top: 10px; border-radius: 4px; border: 1px solid #ccc; }
        button { background-color: #007bff; color: white; cursor: pointer; border: none; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #log { margin-top: 20px; padding: 10px; background-color: #eee; border-radius: 4px; white-space: pre-wrap; height: 150px; overflow-y: scroll; border: 1px solid #ddd; }
        #output-video { margin-top: 20px; max-width: 100%; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚úÇÔ∏è Auto-Cut de Sil√™ncios</h1>
        <p>Aplica√ß√µes WebAssembly com FFmpeg. O processamento ocorre no seu navegador.</p>

        <input type="file" id="file-input" accept="video/*">
        <button id="process-button" onclick="processVideo()" disabled>Processar V√≠deo</button>
        
        <h2>Status e Log:</h2>
        <div id="log">Aguardando inicializa√ß√£o do FFmpeg...</div>

        <h2>V√≠deo de Sa√≠da:</h2>
        <video id="output-video" controls></video>
        <a id="download-link" download="video-sem-silencio.mp4" style="display: none; margin-top: 10px;">Baixar V√≠deo</a>
    </div>

    <script>
        // Vari√°veis globais
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({
            // Exibe o log do FFmpeg no console e no HTML
            log: true, 
            corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js'
        });

        const logElement = document.getElementById('log');
        const fileInput = document.getElementById('file-input');
        const processButton = document.getElementById('process-button');
        const outputVideo = document.getElementById('output-video');
        const downloadLink = document.getElementById('download-link');
        
        // ----------------------------------------------------
        // FUN√á√ÉO DE LOG (Para exibir no console e no HTML)
        // ----------------------------------------------------
        function customLog(message) {
            console.log(message);
            logElement.innerHTML += message + '\n';
            logElement.scrollTop = logElement.scrollHeight; // Scroll para o final
        }

        // ----------------------------------------------------
        // 1. INICIALIZA√á√ÉO DA BIBLIOTECA
        // ----------------------------------------------------
        async function loadFFmpeg() {
            customLog('Iniciando o carregamento do FFmpeg...');
            try {
                // Sobrescreve a fun√ß√£o de log do ffmpeg.wasm para capturar a sa√≠da
                ffmpeg.setLogger(({ message }) => {
                    customLog(`[FFmpeg] ${message}`);
                });
                
                await ffmpeg.load();
                customLog('‚úÖ FFmpeg carregado com sucesso!');
                fileInput.disabled = false;
                
            } catch (error) {
                customLog(`‚ùå Erro ao carregar FFmpeg: ${error.message}. Verifique a consola.`);
            }
        }

        // Chamada de carregamento ao iniciar
        loadFFmpeg();

        // Ativa o bot√£o de processamento assim que um arquivo for selecionado
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0 && ffmpeg.isLoaded()) {
                processButton.disabled = false;
            } else {
                processButton.disabled = true;
            }
            outputVideo.style.display = 'none';
            downloadLink.style.display = 'none';
            logElement.innerHTML = ''; // Limpa o log para um novo processamento
            customLog('Arquivo selecionado. Pronto para processar.');
        });

        // ----------------------------------------------------
        // 2. L√ìGICA DE PROCESSAMENTO PRINCIPAL
        // ----------------------------------------------------
        async function processVideo() {
            const file = fileInput.files[0];
            if (!file) {
                customLog('Selecione um arquivo de v√≠deo primeiro.');
                return;
            }

            processButton.disabled = true;
            outputVideo.style.display = 'none';
            downloadLink.style.display = 'none';
            customLog('Iniciando processamento...');

            const inputFileName = 'input.mp4';
            const tempLogFile = 'silence_log.txt';
            const outputFileName = 'output.mp4';
            
            try {
                // 1. Escrever o arquivo de entrada no sistema de arquivos virtual do FFmpeg
                customLog(`Gravando o arquivo "${inputFileName}" (Tamanho: ${(file.size / (1024 * 1024)).toFixed(2)} MB)...`);
                await ffmpeg.FS('writeFile', inputFileName, await fetchFile(file));
                
                // 2. Detectar sil√™ncios e gravar o log de sa√≠da (IMPORTANTE: usamos `-f null -` para n√£o criar um arquivo, mas sim for√ßar o log)
                // Par√¢metros do silencedetect:
                // -n: N√≠vel de ru√≠do (ex: -30dB). Valores mais altos detectam mais ru√≠do como sil√™ncio.
                // -d: Dura√ß√£o m√≠nima de sil√™ncio para ser detectado (ex: 2 segundos).
                customLog('Executando o comando silencedetect...');
                
                await ffmpeg.run(
                    '-i', inputFileName,
                    '-af', 'silencedetect=n=-30dB:d=1.5', // Ajuste n e d conforme necess√°rio
                    '-f', 'null',
                    '-' 
                );
                
                // 3. Obter o log completo e extrair os timestamps
                const fullLog = logElement.innerText;
                const timestamps = extractTimestamps(fullLog);
                
                if (timestamps.length === 0) {
                    customLog('‚ö†Ô∏è Nenhum sil√™ncio significativo detectado. Processamento cancelado.');
                    processButton.disabled = false;
                    return;
                }
                
                customLog(`‚úÖ Sil√™ncios detectados. Total de segmentos a cortar: ${timestamps.length / 2}`);

                // 4. Calcular os segmentos de n√£o-sil√™ncio (o conte√∫do a ser mantido)
                const segmentsToKeep = calculateKeepSegments(timestamps, file.duration);
                customLog(`Total de clipes de conte√∫do: ${segmentsToKeep.length}`);
                
                if (segmentsToKeep.length === 0) {
                    customLog('‚ö†Ô∏è A an√°lise de sil√™ncio resultou em nenhum clipe para manter. Processamento cancelado.');
                    processButton.disabled = false;
                    return;
                }

                // 5. Cortar e Concatenar os segmentos
                const cutFileNames = [];
                for (let i = 0; i < segmentsToKeep.length; i++) {
                    const { start, end } = segmentsToKeep[i];
                    const duration = (end - start).toFixed(3);
                    const clipName = `clip_${i}.mp4`;
                    cutFileNames.push(clipName);

                    customLog(`Cortando Clip ${i + 1}: Start=${start}s, Dura√ß√£o=${duration}s, Arquivo=${clipName}`);

                    // Comando: -ss (start time), -i (input), -t (duration), -c copy (fast, no re-encode)
                    await ffmpeg.run(
                        '-ss', start.toString(),
                        '-i', inputFileName,
                        '-t', duration,
                        '-c', 'copy', // 'copy' √© crucial para velocidade e qualidade
                        clipName
                    );
                }

                // 6. Criar o arquivo 'concat.txt' para o FFmpeg
                const concatList = cutFileNames.map(name => `file '${name}'`).join('\n');
                await ffmpeg.FS('writeFile', 'concat.txt', concatList);
                
                // 7. Concatenar os clipes em um arquivo final
                customLog('Concatenando clipes...');
                await ffmpeg.run(
                    '-f', 'concat',
                    '-safe', '0',
                    '-i', 'concat.txt',
                    '-c', 'copy',
                    outputFileName
                );
                
                // 8. Ler o arquivo de sa√≠da
                customLog('Leitura do v√≠deo finalizado...');
                const data = ffmpeg.FS('readFile', outputFileName);

                // 9. Exibir e disponibilizar para download
                const videoBlob = new Blob([data.buffer], { type: 'video/mp4' });
                const videoURL = URL.createObjectURL(videoBlob);
                
                outputVideo.src = videoURL;
                outputVideo.style.display = 'block';
                downloadLink.href = videoURL;
                downloadLink.style.display = 'block';
                
                customLog('üéâ Processamento conclu√≠do! Verifique o v√≠deo de sa√≠da.');
                
            } catch (error) {
                customLog(`‚ùå Ocorreu um erro no processamento: ${error.message}`);
                console.error(error);
            } finally {
                // Limpa os arquivos tempor√°rios
                try {
                    ffmpeg.FS('unlink', inputFileName);
                    ffmpeg.FS('unlink', 'concat.txt');
                    // N√£o limpa os clipes de corte para facilitar o debug se necess√°rio.
                } catch(e) {}
                
                processButton.disabled = false;
            }
        }
        
        // ----------------------------------------------------
        // 3. FUN√á√ïES DE PARSE DO LOG E C√ÅLCULO DE SEGMENTOS
        // ----------------------------------------------------
        
        // Extrai os timestamps de in√≠cio e fim do sil√™ncio do log
        function extractTimestamps(logText) {
            const timestamps = [];
            const regex = /silence_start: (\d+\.?\d*)|silence_end: (\d+\.?\d*)/g;
            let match;
            
            while ((match = regex.exec(logText)) !== null) {
                // match[1] √© silence_start, match[2] √© silence_end
                if (match[1]) {
                    timestamps.push({ type: 'start', time: parseFloat(match[1]) });
                } else if (match[2]) {
                    timestamps.push({ type: 'end', time: parseFloat(match[2]) });
                }
            }
            return timestamps;
        }

        // Calcula os trechos de v√≠deo (n√£o-sil√™ncio) que devem ser mantidos
        function calculateKeepSegments(silenceTimestamps, fullDuration = 3600) {
            const segments = [];
            let lastEndTime = 0;

            // A dura√ß√£o completa do arquivo √© necess√°ria, mas o file.duration 
            // no JS pode ser impreciso, ent√£o usaremos um valor alto 
            // ou tentaremos obter a dura√ß√£o real do log do FFmpeg se poss√≠vel.
            // Para este exemplo, vou simular a obten√ß√£o da dura√ß√£o real no log
            // (um FFmpeg "verbose" pode dar essa info).

            // Simplesmente itera sobre os sil√™ncios para encontrar os intervalos entre eles.
            for (let i = 0; i < silenceTimestamps.length; i++) {
                const current = silenceTimestamps[i];
                
                if (current.type === 'start') {
                    const startTime = lastEndTime;
                    const endTime = current.time;
                    
                    if (endTime > startTime + 0.1) { // Garante que o clipe n√£o seja min√∫sculo
                        segments.push({ start: startTime.toFixed(3), end: endTime.toFixed(3) });
                    }
                } else if (current.type === 'end') {
                    lastEndTime = current.time;
                }
            }

            // Adiciona o √∫ltimo segmento (do final do √∫ltimo sil√™ncio at√© o fim do v√≠deo)
            // (Este √© um ponto fraco: se o sil√™ncio final n√£o for detectado no log, 
            // podemos ter a dura√ß√£o incorreta. Uma solu√ß√£o seria rodar um 
            // comando de metadados antes).
            const lastSilenceEnd = silenceTimestamps.length > 0 && silenceTimestamps[silenceTimestamps.length - 1].type === 'end'
                ? silenceTimestamps[silenceTimestamps.length - 1].time
                : 0;

            // Para fins de demonstra√ß√£o, use o valor obtido do √∫ltimo ponto do log se o v√≠deo
            // tiver sido totalmente processado. Voc√™ pode tentar extrair a dura√ß√£o
            // exata do log de INFO do FFmpeg para maior precis√£o.

            // Supondo que o √∫ltimo ponto de sil√™ncio_end seja o fim do √∫ltimo sil√™ncio
            if (lastSilenceEnd > 0) {
                const estimatedFullDuration = lastSilenceEnd + 60; // Dura√ß√£o estimada para evitar cortes prematuros
                if (estimatedFullDuration > lastSilenceEnd + 0.1) {
                     segments.push({ start: lastSilenceEnd.toFixed(3), end: estimatedFullDuration.toFixed(3) });
                }
            }
            
            return segments;
        }

    </script>
</body>
</html>